#! /bin/bash




#VERSION_SUFFIX=$( echo "$APP_NAME""$HOSTNAME" | sed 's/[^0-9a-zA-Z]//g'; echo "xxx")
VERSION_SUFFIX=$( printf "repacked-%s" $( echo "$APP_NAME""$HOSTNAME" | sed 's/[^0-9a-zA-Z]//g' ) )
echo $VERSION_SUFFIX
exit
#
#file="$REPO_DIR/dpkg-repack-21765/DEBIAN/control"
##version_regex="^Version: (.*)$"
#version_regex="Version: ([^[:space:]]*)"
#
#if [[ $(<"$file") =~ $version_regex ]]; then
##if [[ $(<$file) =~ $version_regex ]]; then
#	DEB_PACKAGE_VERSION_ORIGINAL=${BASH_REMATCH[1]}
#fi
#echo $DEB_PACKAGE_VERSION_ORIGINAL
#
#exit
#

DPKG_REPACK_DIR=
capture_dpkg_repack_dir() {
	unset DPKG_REPACK_DIR
	local data
	if [ ! -t 0 ]; then
		read -r data
	else
		data="$*"
	fi
	regex="^dpkg-repack: dpkg-repack: created \.\/(.*) for "
	#regex="^dpkg-repack: (.*) for "
	if [[ $data =~ $regex ]]; then
		DPKG_REPACK_DIR="${BASH_REMATCH[1]}"
	fi
	echo "$data"
}

DPKG_DEB_PACKAGE=
capture_dpkg_deb_package() {
	unset DPKG_DEB_PACKAGE
	local data
	if [ ! -t 0 ]; then
		read -r data
	else
		data="$*"
	fi
	regex="^dpkg-deb: building package .* in \`\.\/(.*)'.$"
	#dpkg-deb: building package `racket' in `./racket_5.3.1+dfsg1-1+aptsaverwSatelliteU305_i386.deb'.
	if [[ $data =~ $regex ]]; then
#		echo "FOUND!"
		DPKG_DEB_PACKAGE="${BASH_REMATCH[1]}"
	fi
	echo "$data"
}

repack() {
	if [[ ${1:0:1} == "/" ]]; then
    	local file_list="$1"
	else
		#parse any multi line or space separated list
		echo "$*" | tr " " "\n" | tr -d "\t" | grep -vP "^$"  > "$DATA_DIR/repack.tmp"
		local file_list="$DATA_DIR/repack.tmp"
	fi

	[[ ! -f "$file_list" ]] && echo "Please provide valid a file list: $file_list" 1>&2 && exit 1
	[[ ! -s "$file_list" ]] && echo '' && return $(true)
	pushd "$REPO_DIR" 1> /dev/null

	local version_regex="Version: ([^[:space:]]*)"
	local package_name
	while IFS= read -r package_name || [[ $package_name ]]; do
		#( (fakeroot -u dpkg-repack --generate "$package_name" | capture_dpkg_repack_dir ) 3>&1 1>&2 2>&3 3>&- | grep -v "contains user-defined field" | grep -vP "^dpkg-deb: warning: ignoring [0-9]+ warning(s)? about the control file" | grep -vP "^\s*$" | grep -vP "^dpkg-deb: building package " | grep -v "Use dpkg --info (= dpkg-deb --info) to examine archive files," | grep -v "and dpkg --contents (= dpkg-deb --contents) to list their contents.")
		# ( (fakeroot -u dpkg-repack --generate "$package_name" | capture_dpkg_repack_dir &>> "$LOG_STD") 3>&1 1>&2 2>&3 3>&- | grep -v "contains user-defined field" | grep -vP "^dpkg-deb: warning: ignoring [0-9]+ warning(s)? about the control file" | grep -vP "^\s*$" | grep -vP "^dpkg-deb: building package " | grep -v "Use dpkg --info (= dpkg-deb --info) to examine archive files," | grep -v "and dpkg --contents (= dpkg-deb --contents) to list their contents.")
		fakeroot -u dpkg-repack --generate "$package_name" 2>&1 | filter_dpkg | capture_dpkg_repack_dir > >(tee -a "$LOG_STD")
		if [[ ! -z "$DPKG_REPACK_DIR" ]]; then
			#echo "$DPKG_REPACK_DIR"
			file="$REPO_DIR/$DPKG_REPACK_DIR/DEBIAN/control"
			#if [[ $(<"$file") =~ $version_regex ]]; then
			#	DEB_PACKAGE_VERSION_ORIGINAL=${BASH_REMATCH[1]}
			#fi
			sed -i 's/^Version: .*$/\0+'"$VERSION_SUFFIX"'/g' "$file"
		fi

		dpkg --build "$REPO_DIR/$DPKG_REPACK_DIR" "."  2>&1 | filter_dpkg | capture_dpkg_deb_package > >(tee -a "$LOG_STD") && {
			#echo "$DPKG_DEB_PACKAGE"
			DEB_PACKAGE_ORIGINAL=$(echo "$DPKG_DEB_PACKAGE" | sed 's/\+'"$VERSION_SUFFIX"'//g')
			#echo $DEB_PACKAGE_ORIGINAL
			#echo $DPKG_DEB_PACKAGE
			[[ ! -z "$DPKG_DEB_PACKAGE" && ! -z $DEB_PACKAGE_ORIGINAL ]] && \
				mv "$REPO_DIR/$DPKG_DEB_PACKAGE" "$REPO_DIR/$DEB_PACKAGE_ORIGINAL"
			[[ ! -z "$DPKG_REPACK_DIR" ]] && \
				rm -fr "$REPO_DIR/$DPKG_REPACK_DIR"
		}
		#dpkg-deb: building package `racket' in `./racket_5.3.1+dfsg1-1+aptsaverwSatelliteU305_i386.deb'.

	done < "$file_list"

	rm -f "$DATA_DIR/repack.tmp" 2> /dev/null
	popd 1> /dev/null
	return 0
}

repack racket  	

exit
#repack_files   $DATA_DIR/test
repack_files 			apparmor  		app-install-data

repack_files 			apparmor  		app-install-data \
\
\
		app-install-data-partner

exit
repack_files_all() {
	local file_list="$1"
	[[ ! -f "$1" ]] && echo "Please provide valid a file list: $file_list" 1>&2 && exit 1
	[[ ! -s "$1" ]] && echo '' && return $(true)
	pushd $REPO_DIR 1> /dev/null
	#( ( fakeroot -u dpkg-repack $(< $file_list) &> "$LOG_STD" ) 3>&1 1>&2 2>&3 | grep -v "contains user-defined field" | grep -vP "^dpkg-deb: warning: ignoring [0-9]+ warning(s)? about the control file" | grep -vP "^\s*$" | grep -vP "^dpkg-deb: building package " | grep -v "Use dpkg --info (= dpkg-deb --info) to examine archive files," | grep -v "and dpkg --contents (= dpkg-deb --contents) to list their contents." )
	( ( fakeroot -u dpkg-repack $(< $file_list) &> "$LOG_STD" ) 3>&1 1>&2 2>&3 | grep -v "contains user-defined field" | grep -vP "^dpkg-deb: warning: ignoring [0-9]+ warning(s)? about the control file" | grep -vP "^\s*$" | grep -vP "^dpkg-deb: building package " | grep -v "Use dpkg --info (= dpkg-deb --info) to examine archive files," | grep -v "and dpkg --contents (= dpkg-deb --contents) to list their contents." )
	exec 3>&-
	popd 1> /dev/null
}

f="$DATA_DIR"/test
#repack_files_all "$f"
repack_files "$f"
exit


printf "%.0f\n" 1232132132.213213213 
exit

local ctime_last_repo=$( find  ~/apt-saver/repository/*.deb -printf '%T@\n' | sort -r | head -1 )
ctime_last_repo=$( echo "($ctime_last_repo/10)*10" | bc )
echo "$ctime_last_repo"
exit
a=100
echo $a
function test() {
	local a=1 b=2
	echo $a
	echo $b

	a=10
	echo $a
}
test
echo $a
echo $b
exit


echo "error" | tee --append hola.txt 1>&2 
echo "file: "
cat hola.txt
exit

function test() {
	local a=1 b=2
	echo $a
	echo $b

}
test
echo $a
echo $b

exit

elapsed_time=$(( (8123450*1)+44 )) 
echo "all in "$(display_time $elapsed_time)
exit

echo Dir::Etc::sourcelist
echo $Dir::Etc::sourcelist

exit

 human_filesize 0
 human_filesize 11
 human_filesize 100
 human_filesize 1000
 human_filesize 1024

 human_filesize 10000
 human_filesize 100000
 human_filesize 1000000
 human_filesize 10000000
 human_filesize 100000000

exit

read -p "Enter Dir for repositories: : " -e -i $(pwd)/ ANSWER
#read -r -e -p "Dir for repositories: " ANSWER
echo $ANSWER
exit

printf "enter your dir: "
read -e test
echo $test

exit

generate_install_step_files 1
exit

	s="   hola como estas 
	"
	s=$(trim $s)
	echo \"$s\"
	echo "final"
exit	
		local source="test3 file:$REPO_DIR ./"
		#local cmd="echo \"$source\" >> $REPOSITORY_SOURCE_FILE"

		cat "$REPOSITORY_SOURCE_FILE"
		local line
		local line_exist=false
		while IFS= read -r line; do
		    if [[ "$line" == "$source" ]]; then
		    	echo "line exists"
				line_exist=true
		    	break
		    fi
		done < "$REPOSITORY_SOURCE_FILE"
		echo $line_exist
		if [[ $line_exist == false ]]; then
			echo "it doesn't exist"
			#sudo sh -c "cat >>$REPOSITORY_SOURCE_FILE" "$source"
			#echo "sudo sh -c ""'"$cmd"'"""
			#$(sudo sh -c "'$cmd'")
			sudo sh -c "cat >>$DATA_DIR/foo.txt" <<-EOF
				$source
EOF
		fi
		exit

		local cmd="echo \"deb file:$REPO_DIR ./\" >> $REPOSITORY_SOURCE_FILE"
		echo "$cmd"
		#sudo $(cmd)
		eval "sudo sh -c 'sudo $cmd'"

exit

		
		package_gz_needs_build && echo "packages needs to be built?: yes"
		exit
		#echo "este es un error" >&2
		BUILD_PACKAGE=false
		#local ctime_last_repo=$(stat -c %Z "$(ls -tc ../../repository/*.deb | head -1)")
		local ctime_last_repo=$( ls -ltc --time-style="+%s" "$REPO_DIR"/*.deb | head -1 | cut -f6 -d " " )
		local ctime_packages_gz=$(stat -c %Z "$PACKAGES_GZ_FILE")

		#if there is no package, build it
		if [[ ! -s "$REPO_DIR/Packages.gz" ]]; then
			BUILD_PACKAGE=true
		#if the lastest .deb modified file
		elif [[ "$ctime_last_repo" -ge "$ctime_packages_gz" ]]; then
			BUILD_PACKAGE=true
		#if packages were created
		elif [[ ! -s installed.new.list ]]; then
			BUILD_PACKAGE=true
		fi
		
		echo "BUILD_PACKAGE: $BUILD_PACKAGE"
		exit


printf "Repacking %s files..." $(get_number_of_lines "$DATA_DIR"/to_install.step3.list)
exit

local download_packages=$(cat "$DATA_DIR"/to_install.to_download.list | paste -s -d " " | tr "\n" " ")
echo "The following packages could not been repacked: $download_packages"
exit

repack_files "$DATA_DIR"/test
exit

#echo get_size_files_installed "$DATA_DIR/test"
#exit

if [[ ! -s "$DATA_DIR"/to_install.to_download.list ]]; then
echo "vacio"

else 
echo "lleno"
fi
exit
#########
# REPACK 
#comm -3 to_install.cached.list packages.repack.list | tr -d " \t" | sort | uniq > to_install.repack.list
#get_files_installed to_install.repack.list > to_install.repack.files
repack_files "$DATA_DIR"/to_install.repack.list
exit

get_size_files_installed "$DATA_DIR/test.list"
exit

source "$APP_DIR/build_apt_data.sh"
build_apt_data_logs

exit
repack_files "$DATA_DIR"/to_install.repack.list
exit